<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">

  <style>
    svg {
      /* border: 1px black solid; */
      background-color: rgb(255, 255, 255);
    }

    .county {
      stroke: none;
    }

    .state {
      stroke: none;
    }

    .county-outline {
      stroke: rgb(255, 255, 255);
      stroke-width: 1px;
      fill: none;
    }

    .state-outline {
      stroke: rgb(255, 255, 255);
      stroke-width: 1px;

      fill: none;
    }

    .arealabel {
      user-select: none;
      pointer-events: none;
      font-weight: bold;
      font-size: large;
    }

    table {
      border: 0;
    }

    th,
    td {
      text-align: left;
      padding: 3px 10px;
      border-bottom: 1px solid #ccc;
    }


    #tableDiv {
      margin: 0;
      padding: 80 0 0 40;
    }

    .legend-lines {
      stroke: black;
      stroke-width: 2px;
    }

    /* label {
      display: block;
      font-size: 22px;
      font-weight: bold;
      cursor: pointer;
      position: relative;
    } */
    #radioBox {
      margin: 0 0 15 0;
      padding: 5px;
      border: 1px solid black;
      border-radius: 5px;
      display: inline-block;
      background-color: lightgray;
      /* box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5); */
    }

    #filterButton {
      display: flex;
      gap: 5px;
    }

    #filterButton label {
      display: block;
      /* padding-bottom: 10px; */
      background-color: lightgray;
      border-radius: 5px;
      cursor: pointer;
    }

    #filterButton input[type="radio"] {
      display: none;
    }

    #filterButton input[type="radio"]:checked+span {
      background-color: #0C4A90;
      padding: 5px;
      color: white;
      border-radius: 5px;
      box-shadow: inset 0px 0px 5px rgba(0, 0, 0, 0.5);
    }

    body {
      margin: 50 150 200 150;
      padding: 0;
      font-family: 'Barlow', sans-serif;
    }

    a {
      color: #025FEF;
    }

    p {
      font-weight: 400;
      font-size: 1.2em;
      line-height: 1.5em;
    }

    p.micro {
      font-size: 1.4em;
      font-weight: 700;
      margin: 0 0 0 5;
      padding: 0;
      color: #025FEF;
    }

    p.source {
      margin: -30 0 0 0;
      padding: 0;
    }

    ul li {
      font-size: 1.15em;
      line-height: 1.75em;
    }

    h1 {
      font-weight: 800;
      font-size: 7em;
      margin: 0 0 100 0;
      padding: 0;
      line-height: 1em;
      color: #025FEF;
    }

    h2 {
      font-weight: 500;
      font-size: 4.5em;
      margin: 0 0 40 0;
      padding: 0;
      line-height: 1em;
    }

    .heavy {
      font-weight: 900;
      background-color: #0261ef2d;
    }

    h3 {
      font-size: 2.4em;
      margin: 60 0 30 0;
      padding: 0;
      line-height: 1em;
      color: #025FEF;
    }

    .rate {
      font-size: .45em;
      color: black;
    }

    h4 {
      font-size: 1.3em;
      margin: 30 0 5 0;
      padding: 0;
    }

    .gridlines .domain {
      display: none;
    }

    .gridlines line {
      stroke: #bebebe;
    }

    .gridtext {
      font-size: .8em;
    }

    .flex-container {
      display: flex;
      flex-wrap: nowrap;
    }

    .flex-container>div {
      width: 1200;
    }

    .notesContainer {
      margin: 0;
      padding: 30 0 0 0;
    }
  </style>
</head>

<body>

  <p class="micro">U.S. STATE AND COUNTY</p>
  <h1>Disability Statistics</h1>
  <h2>Disabled Population<br>in the United States is <span class="heavy">&nbsp;13.4%&nbsp;</span></h2>
  <p class="source">2022 American Community Survey 1-Year Estimates</p>

  <!-- ----------------------------
              LINE CHARTS
      ---------------------------- -->
  <div class="flex-container">
    <div>
      <!-- BY DISABILITY TYPE -->
      <h3><span class="rate">DISABILITY PREVALENCE RATE (%)</span><br>By Disability Type</h3>
      <svg id="typePlot" height="350" width="480">
      </svg>
    </div>
    <div>
      <!-- BY AGE -->
      <h3><span class="rate">DISABILITY PREVALENCE RATE (%)</span><br>By Age</h3>
      <svg id="agePlot" height="350" width="480">
      </svg>
    </div>
    <div>
      <!-- BY RACE -->
      <h3><span class="rate">DISABILITY PREVALENCE RATE (%)</span><br>By Race</h3>
      <svg id="racePlot" height="350" width="480">
      </svg>
    </div>
  </div>
  <div>
    <p style="font-size: 1.1em;">
      <span style="color: #025FEF; font-weight: bold;">FUN TIP:</span> Click the chart labels to toggle dot visability
      on and off.<br>
      <b>NOTE:</b> 2020 data is missing due to poor biased response rates during COVID.
    </p>
  </div>

  <!-- ----------------------------
            CHOROPLETH & TABLE
      ---------------------------- -->
  <div>
    <h3><span class="rate">DISABILITY PREVALENCE</span><br>By State and County</h3>
  </div>

  <!-- STATE/COUNTY TOGGLE BUTTON -->
  <div id="radioBox">
    <div id="filterButton">
      <label>
        <input type="radio" id="stateView" name="filterButton" value="state" checked>
        <span>State View </span>
      </label>
      <label>
        <input type="radio" id="countyView" name="filterButton" value="county">
        <span>County View</span>
      </label>
    </div>
  </div>


  <div class="flex-container">
    <div>
      <!-- CHOROPLETH -->
      <svg id="chloroMap" height="600" width="1000"></svg>
      <!-- CHOROPLETH LEGEND -->
      <svg id="legend" height="200" width="400" style="padding-left:300;"></svg>
    </div>
    <div>
      <!-- DATA TABLE -->
      <div id="tableDiv">
        <table id="table">
          <thead>
            <tr id="header">
              <th>Disability&nbsp;Type&nbsp;(ages)</th>
              <th>%</th>
              <th>MOE</th>
              <th>Number</th>
              <th>MOE</th>
              <th>Base&nbsp;Population</th>
            </tr>
          </thead>
          <tbody>
            <tr id="row1">
              <th>Any Disability (<18)< /td>
              <td>10.1</td>
              <td>±0.8</td>
              <td>10,199</td>
              <td>±799</td>
              <td>101,394</td>
            </tr>
            <tr id="row2">
              <th>Hearing (<18)< /td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row3">
              <th>Hearing (18-64)</td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row4">
              <th>Visual (<18)< /td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row5">
              <th>Visual (18-64)</td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row6">
              <th>Cognitive (<18)< /td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row7">
              <th>Cognitive (18-64)</td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row8">
              <th>Ambulatory (<18)< /td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row9">
              <th>Ambulatory (18-64)</td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row10">
              <th>Selfcare (<18)< /td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row11">
              <th>Selfcare (18-64)</td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
            <tr id="row12">
              <th>Independent Living (18-64)</td>
              <td>2.5</td>
              <td>±0.4</td>
              <td>2,574</td>
              <td>±359</td>
              <td>101,394</td>
            </tr>
          </tbody>
        </table>
        <p style="font-size: 1em; padding: 0 15;">MOE: Margin of Error</p>
      </div>

    </div>
  </div>


  <!-- NOTES -->
  <div class="notesContainer">
    <h4>Notes</h4>
    <p>
      All estimates provided by these visualizations are based on the the most recently available US Census Bureau’s
      American Community Survey (ACS) data 5 year estimates collected from 2017-2022.
      Because the estimates below are based on a sample they have a degree of uncertainty, called sampling error,
      associated with them. In general, the larger the sample, the smaller the level of sampling error. To help users
      understand the impact of sampling error on data reliability, we provide the margin of error (MOE) for each
      estimate. The MOE, combined with the estimate, gives users a range of values within which the actual, real-world
      value is likely to fall.
    </p>
  </div>
  <!-- SOURCES & LINKS -->
  <div class="sourceContainer">
    <h4>Data Source</h4>
    <ul>
      <li>American Community Survey (ACS): S1810 | Disability Characteristics (<a
          href="https://data.census.gov/table?q=Disability">https://data.census.gov/table?q=Disability</a>)</li>
    </ul>
  </div>



  <!---   ==============================
        PREVALENCE: BY DISABILITY TYPE
        ============================== --->
  <script id="notes1">
    // set the dimensions and margins of the graph
    const disLines = d3.select("svg#typePlot");
    const disWidth = disLines.attr("width");
    const disHeight = disLines.attr("height");
    const disMargin = { top: 10, right: 155, bottom: 40, left: 40 };
    const chartWidth = disWidth - disMargin.left - disMargin.right;
    const chartHeight = disHeight - disMargin.top - disMargin.bottom;

    let chartArea = disLines.append("g")
      .attr("transform", `translate(${disMargin.left},${disMargin.top})`);

    // DATA
    d3.csv("prevDisType-01.csv",
      d => {
        return {
          time: d3.timeParse("%Y")(d.time), Disability: d.Disability,
          Hearing: d.Hearing,
          Vision: d.Vision,
          Cognitive: d.Cognitive,
          Ambulatory: d.Ambulatory,
          Selfcare: d.Selfcare,
          IndLiving: d.IndependentLiving
        }
      }
    ).then(function (data) {

      // List of groups (here I have one group per column)
      const allGroup = ["Disability", "Hearing", "Vision", "Cognitive", "Ambulatory", "Selfcare", "IndLiving"]

      // Reformat the data: we need an array of arrays of {x, y} tuples
      const dataReady = allGroup.map(function (grpName) { // .map allows to do something for each element of the list
        return {
          name: grpName,
          values: data.map(function (d) {
            return { time: d.time, value: +d[grpName] };
          })
        };
      });



      // Color Scale: one color for each group
      const myColor = d3.scaleOrdinal()
        .domain(allGroup)
        .range(d3.schemeCategory10);
      //.range(["#eee", "#ccc"]);

      // X-AXIS
      const x = d3.scaleTime()
        .domain(d3.extent(data, d => d.time))
        .range([0, chartWidth]);
      // x-axis: years
      chartArea.append("g")
        .attr("transform", `translate(0, ${chartHeight + 10})`)
        .attr("class", "gridtext")
        .call(d3.axisBottom(x).ticks(5).tickSizeOuter(5).tickSize(7));
      // grey base grid
      chartArea.append("g")
        .attr("transform", `translate(0, ${chartHeight + 10})`)
        .call(d3.axisBottom(x).tickSizeOuter(5).tickSize(-chartHeight).tickFormat(""))
        .attr("class", "gridlines");


      // Y-AXIS
      const y = d3.scaleLinear()
        .domain([1, 14])
        .range([chartHeight, 0]);
      // y-axis numbers
      chartArea.append("g")
        .attr("transform", `translate(-13, 0)`)
        .attr("class", "gridtext")
        .call(d3.axisLeft(y).ticks(5).tickSize(7).tickSizeOuter(5));

      // Add LINES
      const line = d3.line()
        .x(d => x(+d.time))
        .y(d => y(+d.value))
      chartArea.selectAll("myLines")
        .data(dataReady)
        .join("path")
        //.attr("class", d => d.name)
        .attr("d", d => line(d.values))
        .attr("stroke", d => myColor(d.name))
        .attr("opacity", .3)
        .style("stroke-width", 3)
        .style("fill", "none")

      // Add POINTS
      chartArea
        // Enter in a group
        .selectAll("myDots")
        .data(dataReady)
        .join('g')
        .style("fill", d => myColor(d.name))
        .attr("class", d => d.name)
        // Second we need to enter in the 'values' part of this group
        .selectAll("myPoints")
        .data(d => d.values)
        .join("circle")
        .attr("cx", d => x(d.time))
        .attr("cy", d => y(d.value))
        .attr("r", 6)
        .attr("stroke", "white")

        // mouseover
        .on("mouseover", function (event, d) {
          let circle = d3.select(this)
          let parentData = d3.select(this.parentNode).datum() // get data from the parent of the circle which is the g tag
          circle.attr("stroke", "black")
            .attr("stroke-width", "5")
          let xPos = x(d.time) // where the x is
          let yPos = y(d.value) // where the y is

          const formatTime = d3.utcFormat("%Y"); // format the date for the tooltip
          let g = chartArea.append("g")
            .attr("transform", `translate(${xPos}, ${yPos})`)
            .attr("class", "mouseOverLabel")
            .style("pointer-events", "none")
          g.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", 110)
            .attr("height", 40)
            .attr("fill", "white")
            .attr("stroke", myColor(parentData.name))
          g.append("text")
            .attr("x", 5)
            .attr("y", 15)
            .text("Year: " + formatTime(d.time))
          g.append("text")
            .attr("x", 5)
            .attr("y", 35)
            .text("Rate (%): " + d.value)
        })
        // mouseout
        .on("mouseout", function (event, d) {
          let circle = d3.select(this)
          let parentData = d3.select(this.parentNode).datum() // get data from the parent of the circle which is the g tag
          circle.attr("stroke", "white")
            .attr("stroke-width", "1")
          chartArea.select(".mouseOverLabel").remove() // find the thing with the class and remove it
        })

      // Add a legend (interactive)
      chartArea
        .selectAll("myLegend")
        .data(dataReady)
        .join('g')
        .append("text")
        .attr('x', 310)
        .attr('y', (d, i) => 20 + i * 29)
        .text(d => d.name)
        .style("fill", d => myColor(d.name))
        .style("font-size", 18)
        .on("click", function (event, d) {
          // is the element currently visible ?
          currentOpacity = d3.selectAll("." + d.name).style("opacity")
          // Change the opacity: from 0 to 1 or from 1 to 0
          d3.selectAll("." + d.name).transition().style("opacity", currentOpacity == 1 ? 0 : 1)
        })
    })
  </script>
  <!---   ==============================
              PREVALENCE: BY AGE
        ============================== --->
  <script id="notes2">
    // set the dimensions and margins of the graph
    const ageLines = d3.select("svg#agePlot");
    const ageWidth = ageLines.attr("width");
    const ageHeight = ageLines.attr("height");
    const ageMargin = { top: 10, right: 155, bottom: 40, left: 40 };
    const ageChartWidth = ageWidth - ageMargin.left - ageMargin.right;
    const ageChartHeight = ageHeight - ageMargin.top - ageMargin.bottom;

    let ageChartArea = ageLines.append("g")
      .attr("transform", `translate(${ageMargin.left},${ageMargin.top})`);

    // DATA
    d3.csv("prevAge-01.csv",
      d => {
        return {
          time: d3.timeParse("%Y")(d.time), Under5: d.under5,
          Age5to17: d.age5to17,
          Age18to34: d.age18to34,
          Age35to64: d.age35to64,
          Age65to74: d.age65to74,
          Over75: d.over75
        }
      }
    ).then(function (data) {

      // List of groups (here I have one group per column)
      const allGroup = ["Under5", "Age5to17", "Age18to34", "Age35to64", "Age65to74", "Over75"]

      // Reformat the data: we need an array of arrays of {x, y} tuples
      const dataReady = allGroup.map(function (grpName) { // .map allows to do something for each element of the list
        return {
          name: grpName,
          values: data.map(function (d) {
            return { time: d.time, value: +d[grpName] };
          })
        }; u
      });

      // console
      // console.log(dataReady)

      // Color Scale: one color for each group
      const myColor = d3.scaleOrdinal()
        .domain(allGroup)
        .range(d3.schemeCategory10);

      // X-AXIS
      const x = d3.scaleTime()
        .domain(d3.extent(data, d => d.time))
        .range([0, ageChartWidth]);
      // x-axis: years
      ageChartArea.append("g")
        .attr("transform", `translate(0, ${ageChartHeight + 10})`)
        .attr("class", "gridtext")
        .call(d3.axisBottom(x).ticks(5).tickSizeOuter(0).tickSize(7));
      // grey base grid
      ageChartArea.append("g")
        .attr("transform", `translate(0, ${ageChartHeight + 10})`)
        .call(d3.axisBottom(x).tickSizeOuter(0).tickSize(-ageChartHeight).tickFormat(""))
        .attr("class", "gridlines");


      // Y-AXIS
      const y = d3.scaleLinear()
        .domain([0, 50])
        .range([ageChartHeight, 0]);
      // y-axis numbers
      ageChartArea.append("g")
        .attr("transform", `translate(-13, 0)`)
        .attr("class", "gridtext")
        .call(d3.axisLeft(y).ticks(5).tickSize(7).tickSizeOuter(0));

      // Add LINES
      const line = d3.line()
        .x(d => x(+d.time))
        .y(d => y(+d.value))
      ageChartArea.selectAll("myLines")
        .data(dataReady)
        .join("path")
        //.attr("class", d => d.name)
        .attr("d", d => line(d.values))
        .attr("stroke", d => myColor(d.name))
        .attr("opacity", .3)
        .style("stroke-width", 3)
        .style("fill", "none")

      // Add POINTS
      ageChartArea
        // Enter in a group
        .selectAll("myDots")
        .data(dataReady)
        .join('g')
        .style("fill", d => myColor(d.name))
        .attr("class", d => d.name)
        // Second we need to enter in the 'values' part of this group
        .selectAll("myPoints")
        .data(d => d.values)
        .join("circle")
        .attr("cx", d => x(d.time))
        .attr("cy", d => y(d.value))
        .attr("r", 6)
        .attr("stroke", "white")
        // mouseover
        .on("mouseover", function (event, d) {
          let circle = d3.select(this)
          let parentData = d3.select(this.parentNode).datum() // get data from the parent of the circle which is the g tag
          circle.attr("stroke", "black")
            .attr("stroke-width", "5")
          let xPos = x(d.time) // where the x is
          let yPos = y(d.value) // where the y is

          const formatTime = d3.utcFormat("%Y"); // format the date for the tooltip
          let g = ageChartArea.append("g")
            .attr("transform", `translate(${xPos}, ${yPos})`)
            .attr("class", "mouseOverLabel")
            .style("pointer-events", "none")
          g.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", 110)
            .attr("height", 40)
            .attr("fill", "white")
            .attr("stroke", myColor(parentData.name))
          g.append("text")
            .attr("x", 5)
            .attr("y", 15)
            .text("Year: " + formatTime(d.time))
          g.append("text")
            .attr("x", 5)
            .attr("y", 35)
            .text("Rate (%): " + d.value)
        })
        // mouseout
        .on("mouseout", function (event, d) {
          let circle = d3.select(this)
          let parentData = d3.select(this.parentNode).datum() // get data from the parent of the circle which is the g tag
          circle.attr("stroke", "white")
            .attr("stroke-width", "1")
          ageChartArea.select(".mouseOverLabel").remove() // find the thing with the class and remove it
        })


      // Add a legend (interactive)
      ageChartArea
        .selectAll("myLegend")
        .data(dataReady)
        .join('g')
        .append("text")
        .attr('x', 310)
        .attr('y', (d, i) => 20 + i * 30)
        .text(d => d.name)
        .style("fill", d => myColor(d.name))
        .style("font-size", 18)
        .on("click", function (event, d) {
          // is the element currently visible ?
          currentOpacity = d3.selectAll("." + d.name).style("opacity")
          // Change the opacity: from 0 to 1 or from 1 to 0
          d3.selectAll("." + d.name).transition().style("opacity", currentOpacity == 1 ? 0 : 1)
        })
    })

  </script>

  <!---   ==============================
              PREVALENCE: BY RACE
        ============================== --->
  <script id="notes3">
    // set the dimensions and margins of the graph
    const raceLines = d3.select("svg#racePlot");
    const raceWidth = raceLines.attr("width");
    const raceHeight = raceLines.attr("height");
    const raceMargin = { top: 10, right: 155, bottom: 40, left: 40 };
    const raceChartWidth = raceWidth - raceMargin.left - raceMargin.right;
    const raceChartHeight = raceHeight - raceMargin.top - raceMargin.bottom;

    let raceChartArea = raceLines.append("g")
      .attr("transform", `translate(${raceMargin.left},${raceMargin.top})`);

    // DATA
    d3.csv("prevRace-01.csv",
      d => {
        return {
          time: d3.timeParse("%Y")(d.time), White: d.White,
          BlackAA: d.BlackAA,
          AmerIndAKNat: d.AmerIndAKNat,
          Asian: d.Asian,
          HawaiianPI: d.HawaiianPI,
          OtherRace: d.OtherRace,
          TwoPlusRaces: d.TwoPlusRaces,
          WhiteNotHisp: d.WhiteNotHisp,
          HispAnyRace: d.HispAnyRace
        }
      }
    ).then(function (data) {

      // List of groups (here I have one group per column)
      const allGroup = ["White", "BlackAA", "AmerIndAKNat", "Asian", "HawaiianPI", "OtherRace", "TwoPlusRaces", "WhiteNotHisp", "HispAnyRace"]

      // Reformat the data: we need an array of arrays of {x, y} tuples
      const dataReady = allGroup.map(function (grpName) { // .map allows to do something for each element of the list
        return {
          name: grpName,
          values: data.map(function (d) {
            return { time: d.time, value: +d[grpName] };
          })
        };
      });



      // Color Scale: one color for each group
      const myColor = d3.scaleOrdinal()
        .domain(allGroup)
        .range(d3.schemeCategory10);

      // X-AXIS
      const x = d3.scaleTime()
        .domain(d3.extent(data, d => d.time))
        .range([0, raceChartWidth]);
      // x-axis: years
      raceChartArea.append("g")
        .attr("transform", `translate(0, ${raceChartHeight + 10})`)
        .attr("class", "gridtext")
        .call(d3.axisBottom(x).ticks(5).tickSizeOuter(5).tickSize(7));
      // grey base grid
      raceChartArea.append("g")
        .attr("transform", `translate(0, ${raceChartHeight + 10})`)
        .call(d3.axisBottom(x).tickSizeOuter(5).tickSize(-raceChartHeight).tickFormat(""))
        .attr("class", "gridlines");


      // Y-AXIS
      const y = d3.scaleLinear()
        .domain([6, 18])
        .range([raceChartHeight, 0]);
      // y-axis numbers
      raceChartArea.append("g")
        .attr("transform", `translate(-13, 0)`)
        .attr("class", "gridtext")
        .call(d3.axisLeft(y).ticks(5).tickSize(7).tickSizeOuter(5));

      // Add LINES
      const line = d3.line()
        .x(d => x(+d.time))
        .y(d => y(+d.value))
      raceChartArea.selectAll("myLines")
        .data(dataReady)
        .join("path")
        //.attr("class", d => d.name)
        .attr("d", d => line(d.values))
        .attr("stroke", d => myColor(d.name))
        .attr("opacity", .3)
        .style("stroke-width", 3)
        .style("fill", "none")

      // Add POINTS
      raceChartArea
        // Enter in a group
        .selectAll("myDots")
        .data(dataReady)
        .join('g')
        .style("fill", d => myColor(d.name))
        .attr("class", d => d.name)
        // Second we need to enter in the 'values' part of this group
        .selectAll("myPoints")
        .data(d => d.values)
        .join("circle")
        .attr("cx", d => x(d.time))
        .attr("cy", d => y(d.value))
        .attr("r", 6)
        .attr("stroke", "white")

        // mouseover
        .on("mouseover", function (event, d) {
          let circle = d3.select(this)
          let parentData = d3.select(this.parentNode).datum() // get data from the parent of the circle which is the g tag
          circle.attr("stroke", "black")
            .attr("stroke-width", "5")
          let xPos = x(d.time) // where the x is
          let yPos = y(d.value) // where the y is

          const formatTime = d3.utcFormat("%Y"); // format the date for the tooltip
          let g = raceChartArea.append("g")
            .attr("transform", `translate(${xPos}, ${yPos})`)
            .attr("class", "mouseOverLabel")
            .style("pointer-events", "none")
          g.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", 110)
            .attr("height", 40)
            .attr("fill", "white")
            .attr("stroke", myColor(parentData.name))
          g.append("text")
            .attr("x", 5)
            .attr("y", 15)
            .text("Year: " + formatTime(d.time))
          g.append("text")
            .attr("x", 5)
            .attr("y", 35)
            .text("Rate (%): " + d.value)
        })
        // mouseout
        .on("mouseout", function (event, d) {
          let circle = d3.select(this)
          let parentData = d3.select(this.parentNode).datum() // get data from the parent of the circle which is the g tag
          circle.attr("stroke", "white")
            .attr("stroke-width", "1")
          raceChartArea.select(".mouseOverLabel").remove() // find the thing with the class and remove it
        })

      // Add a legend (interactive)
      raceChartArea
        .selectAll("myLegend")
        .data(dataReady)
        .join('g')
        .append("text")
        .attr('x', 310)
        .attr('y', (d, i) => 20 + i * 30)
        .text(d => d.name)
        .style("fill", d => myColor(d.name))
        .style("font-size", 18)
        .on("click", function (event, d) {
          // is the element currently visible ?
          currentOpacity = d3.selectAll("." + d.name).style("opacity")
          // Change the opacity: from 0 to 1 or from 1 to 0
          d3.selectAll("." + d.name).transition().style("opacity", currentOpacity == 1 ? 0 : 1)
        })
    })

  </script>


  <script>
    /*  
    =================== hover effect ===========================================
    */
    const labelRectangleHeight = 40;
    const pixelsPerLetter = 11; //used to calculate width of rectangle
    const areaNameFontSize = 14;
    const percentageFontSize = 12;
    const labelVerticalAdjustment = 25;
    /*
    =================== color legends ==========================================
    */
    const stateLegendX = 25; //position from top left corner of the second svg. 
    const stateLegendY = 100;

    const countyLegendX = 25;
    const countyLegendY = 100;

    const boxHeight = 20;
    const boxWidth = 40;
    const boxTextSeperation = 25; //horizontal distance between start of the leftmost letter and the left of the box 
    const textVerticalAdjustment = 15; //probably don't change this one unless you change font or font size
    const extraLineHeight = 10;

    /*
    ========================= table ============================================
    */



    const row1 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population",
      "Estimate!!Total!!Total civilian noninstitutionalized population"];
    // Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty

    const row2 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Estimate!!Total!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years"];

    const row3 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Estimate!!Total!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years"];

    const row4 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years"
    ];


    const row5 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years"
    ];

    const row6 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years"
    ];

    const row7 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years"
    ];

    const row8 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years"
    ];


    const row9 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years"
    ];

    const row10 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years"
    ];

    const row11 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years"
    ];

    const row12 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years"
    ];

    const tableKeys = [row1, row2, row3, row4, row5, row6, row7, row8, row9, row10, row11, row12];



    function updateTable(dataObject) {
      let tbody = d3.select("table#table tbody");
      let rows = tbody.selectAll("tr");
      rows.each(function (_, rowIndex) {
        let cells = d3.select(this).selectAll("td");
        cells.each(function (_, cellIndex) {
          let cell = d3.select(this);
          let propertyName = tableKeys[rowIndex][cellIndex];


          if (propertyName == undefined) {
            if (rowIndex % 2 == 0) {
              propertyName = tableKeys[1][cellIndex];
            } else {
              propertyName = tableKeys[2][cellIndex];

            }
          }
          cell.text(dataObject[propertyName]);
        });
      });

    }



    d3.select("table#table").style("visibility", "hidden");
    let countyMode = false;

    async function makeChloro() {
      d3.selectAll("input[name='filterButton']").on("change", toggleView);

      let topo = await d3.json("us.json"); let
        filteredStates = ['72', '78']; topo.objects.states.geometries = topo.objects.states.geometries.filter(d => {
          return filteredStates.indexOf(d.id.toString().padStart(2, '0')) === -1;
        });

      let disabilityData = await d3.csv("ACSST5Y2022.S1810-Data.csv");

      disabilityData.forEach(d => {
        d["Geography"] = Number(d["Geography"].substr(9));
        d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"] = Number(d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]);
      });



      fipsToStats = {};

      disabilityData.forEach(d => {
        fipsToStats[d["Geography"]] = d;
      });


      // for a combined scale if wanted
      let allPercentages = d3.map(disabilityData, d => {
        return Number(d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]);
      });
      let statePercentages = disabilityData.map(d => {
        if (!d["Geographic Area Name"].includes(",")) return d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"];
      });

      let countyPercentages = disabilityData.map(d => {
        if (d["Geographic Area Name"].includes(",")) return d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"];
      });


      let colors = ["#CFE1F2", "#B5D4E9", "#93C3DF", "#6DAED5", "#4B97C9", "#2F7EBC", "#1864AA", "#0A4A90", "#08306B"];

      let percentageExtent = d3.extent(allPercentages);
      let adjustedPurple = d3.schemeBlues[9].slice(2);

      let colorScaleState = d3.scaleQuantize(d3.extent(statePercentages), colors);
      let colorScaleCounty = d3.scaleQuantize(d3.extent(countyPercentages), colors);
      // 
      // 
      // Legend Stuff
      // 
      // 
      let svg = d3.select("svg#legend");

      const numberOfSteps = colorScaleState.range().length;
      const legendData = colorScaleState.range().map((color, i) => {
        const extent = colorScaleState.invertExtent(color);
        return {
          color: color,
          minValue: extent[0],
          maxValue: extent[1]
        };
      });


      svg.append("text")
        .text("Prevalence Rate of Disability (%)")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("user-select", "none")
        .attr("transform", `translate(${numberOfSteps * boxWidth / 2}, ${75})`);
      let legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${stateLegendX}, ${stateLegendY})`); // Adjust x, y to position your legend



      // Draw legend boxes
      legend.selectAll(".legend-box")
        .data(legendData)
        .enter()
        .append("rect")
        .attr("class", "legend-box")
        .attr("x", (d, i) => i * boxWidth)
        .attr("y", 0)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .style("fill", d => d.color);

      // Add legend labels
      legend.selectAll(".legend-label")
        .data(legendData)
        .enter()
        .append("text")
        .attr("class", "legend-label")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "hanging")
        .style("user-select", "none")
        .attr("x", (d, i) => i * boxWidth) // Adjust position relative to boxes
        .attr("y", boxHeight + extraLineHeight) // Align text with boxes
        .text((d, i) => {
          if (i == numberOfSteps - 1) return `${d.minValue.toFixed(1)}`;
          return `${d.minValue.toFixed(1)}`;
        });

      legend.selectAll(".legend-lines")
        .data(legendData)
        .enter()
        .append("line")
        .attr("class", "legend-lines")
        .attr("x1", (d, i) => i * boxWidth)
        .attr("x2", (d, i) => i * boxWidth)
        .attr("y1", 0)
        .attr("y2", boxHeight + extraLineHeight);

      let legend2 = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${countyLegendX}, ${countyLegendY})`)
        .style("display", "none");
      numberOfStepsCounty = colorScaleCounty.range().length;
      const legendDataCounty = colorScaleCounty.range().map((color, i) => {
        const extent = colorScaleCounty.invertExtent(color);
        return {
          color: color,
          minValue: extent[0],
          maxValue: extent[1]
        };
      });


      // Draw legend boxes
      legend2.selectAll(".legend-box")
        .data(legendDataCounty)
        .enter()
        .append("rect")
        .attr("class", "legend-box")
        .attr("x", (d, i) => i * boxWidth)
        .attr("y", 0)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .style("fill", d => d.color);

      // Add legend labels
      legend2.selectAll(".legend-label")
        .data(legendDataCounty)
        .enter()
        .append("text")
        .attr("class", "legend-label")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "hanging")
        .style("user-select", "none")
        .attr("x", (d, i) => i * boxWidth) // Adjust position relative to boxes
        .attr("y", boxHeight + extraLineHeight) // Align text with boxes
        .text((d, i) => {
          if (i == numberOfSteps - 1) return `${d.minValue.toFixed(1)}`;
          return `${d.minValue.toFixed(1)}`;
        });

      legend2.selectAll(".legend-lines")
        .data(legendDataCounty)
        .enter()
        .append("line")
        .attr("class", "legend-lines")
        .attr("x1", (d, i) => i * boxWidth)
        .attr("x2", (d, i) => i * boxWidth)
        .attr("y1", 0)
        .attr("y2", boxHeight + extraLineHeight);

      //

      function showCountyLegend() {
        legend.style("display", "none");
        legend2.style("display", null);
      }

      function showStateLegend() {
        legend.style("display", null);
        legend2.style("display", "none");
      }


      let states = topojson.feature(topo, topo.objects.states);
      let statesMesh = topojson.mesh(topo, topo.objects.states);
      let counties = topojson.feature(topo, topo.objects.counties);
      let countiesMesh = topojson.mesh(topo, topo.objects.counties);

      let map = d3.select("svg#chloroMap");
      let w = map.attr("width");
      let h = map.attr("height");
      let projection = d3.geoAlbersUsa().fitSize([w, h], states);
      let path = d3.geoPath().projection(projection);

      let viewport = map.append("g");

      viewport.selectAll(".state").data(states.features)
        .enter()
        .append("path")
        .attr("class", "state")
        .attr("id", d => d.id)
        .attr("d", path);

      viewport.append("path")
        .datum(statesMesh)
        .attr("class", "state-outline")
        .attr("d", path);


      viewport.selectAll(".county").data(counties.features)
        .enter()
        .append("path")
        .attr("class", "county")
        .attr("d", path);

      viewport.append("path")
        .datum(countiesMesh)
        .attr("class", "county-outline")
        .attr("d", path);

      let areaLabel = map.append("g").style("pointer-events", "none");
      let areaLabelRect = areaLabel.append("rect");

      const trianglePoints = [[-10, 0], [10, 0], [0, 20]]
      let areaLabelTriangle = areaLabel.append("polygon")
        .attr("points", trianglePoints.map(point => point.join(",")).join(" "))
        .style("fill", "orangered")
        .style("stroke-width", 1);
      let areaLabelName = areaLabel.append("text")
        .attr("class", "arealabel")
        .style("font-size", `${areaNameFontSize} px`);
      let areaLabelStat = areaLabel.append("text")
        .attr("class", "areastat")
        .style("font-size", `${percentageFontSize} px`);

      areaLabel.attr("visibility", "hidden");




      //zooming
      var zoom = d3.zoom()
        .scaleExtent([1, 20])
        .translateExtent([[-50, -50], [w + 50, h + 50]])
        .on("zoom", mapZoom);

      map.call(zoom);
      //to hide counties
      map.call(zoom.transform, d3.zoomIdentity);

      function mapZoom({ transform }) {
        viewport.attr("transform", transform.toString());
        viewport.select(".state-outline")
          .style("stroke-width", 2 / transform.k);
        viewport.select(".county-outline")
          .style("stroke-width", 1 / transform.k);

        if (!countyMode) {
          viewport.select(".county-outline")
            .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
          viewport.selectAll(".county")
            .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
        }



        if (transform.k > 3) {
          showCountyLegend();
          stateUnhover();
        } else if (!countyMode) {
          showStateLegend();
        }

      }


      viewport.selectAll(".state").on("click", mapClicked);
      viewport.selectAll(".county").on("click", mapClicked);

      viewport.selectAll(".state")
        .attr("fill", d => {
          let val = fipsToStats[d.id];
          if (!val) {
            console.error('No data for id:', d.id);
            return '#000';
          }
          return colorScaleState(Number(fipsToStats[d.id]["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]))
        });

      viewport.selectAll(".county").attr("fill", d => {
        const stats = fipsToStats[d.id];
        if (!stats) {
          return "#000";
        }
        return colorScaleCounty(Number(stats["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]));
      });
      viewport.selectAll(".state").on("mouseover", stateHover).on("mouseleave", stateUnhover);
      viewport.selectAll(".county").on("mouseover", countyHover).on("mouseleave", countyUnhover);




      function stateHover(event, d) {
        d3.selectAll(".state")
          .style("opacity", .4);
        d3.select(this).raise()
          .style("opacity", 1)
          .style("stroke", "orangered")
          .style("stroke-width", "3px");


        // label stuff
        let bounds = path.bounds(d.geometry);
        //
        let transform = d3.zoomTransform(map.node());
        bounds[0] = transform.apply(bounds[0]);
        bounds[1] = transform.apply(bounds[1]);

        let dW = bounds[1][0] - bounds[0][0];
        let dH = bounds[1][1] - bounds[0][1];
        let cx = (bounds[0][0] + bounds[1][0]) / 2;
        let ty = (bounds[0][1]) - labelVerticalAdjustment;
        let cy = (bounds[0][1] + bounds[1][1]) / 2;
        areaLabel.attr("visibility", "visible");


        let areaName = fipsToStats[d.id]["Geographic Area Name"];
        areaLabelName
          .text(areaName)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", labelRectangleHeight / 3);

        areaLabelStat
          .text(fipsToStats[d.id]["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"] + "%")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", 5 + 2 * labelRectangleHeight / 3);

        areaLabelRect
          .attr("width", areaName.length * pixelsPerLetter)
          .attr("height", labelRectangleHeight)
          .attr("rx", 0)
          .attr("fill", "orangered")

        areaLabelTriangle
          .attr("transform", `translate(${areaLabelRect.attr("width") / 2}, ${labelRectangleHeight})`)

        areaLabel.attr("transform", `translate(${cx - areaLabelRect.attr("width") / 2}, ${ty})`).raise();

        // table stuff
        d3.select("table#table").style("visibility", "visible");
        updateTable(fipsToStats[d.id]);

      }

      function stateUnhover(event, d) {
        d3.selectAll(".state").lower()
          .style("opacity", 1)
          .style("stroke", "none");


        areaLabelName.text("");
        areaLabelStat.text("");
        areaLabel.attr("visibility", "hidden");

        d3.select("table#table").style("visibility", "hidden");
      }

      function countyHover(event, d) {
        d3.select(this).raise()
          .style("opacity", 1)
          .style("stroke", "orangered");

        let bounds = path.bounds(d.geometry);
        let transform = d3.zoomTransform(map.node());
        bounds[0] = transform.apply(bounds[0]);
        bounds[1] = transform.apply(bounds[1]);

        let dW = bounds[1][0] - bounds[0][0];
        let dH = bounds[1][1] - bounds[0][1];
        let cx = (bounds[0][0] + bounds[1][0]) / 2;
        let cy = (bounds[0][1] + bounds[1][1]) / 2;
        areaLabel.attr("visibility", "visible");

        let areaName = fipsToStats[d.id]["Geographic Area Name"];
        areaLabelName
          .text(areaName)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", labelRectangleHeight / 3);

        areaLabelStat
          .text(fipsToStats[d.id]["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"] + "%")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", 5 + 2 * labelRectangleHeight / 3);

        areaLabelRect
          .attr("width", areaName.length * pixelsPerLetter)
          .attr("height", labelRectangleHeight)
          .attr("rx", 0)
          .attr("fill", "orangered")

        areaLabelTriangle
          .attr("transform", `translate(${areaLabelRect.attr("width") / 2}, ${labelRectangleHeight})`)

        areaLabel.attr("transform", `translate(${cx - areaLabelRect.attr("width") / 2}, ${cy - dH / 2 - labelRectangleHeight - 5})`).raise();

        d3.select("table#table").style("visibility", "visible");
        updateTable(fipsToStats[d.id]);

      }

      function countyUnhover(event, d) {
        d3.select(this).lower()
          .style("opacity", 1)
          .style("stroke", "none");
        d3.selectAll(".state").lower();

        areaLabelName.text("");
        areaLabel.attr("visibility", "hidden");


        d3.select("table#table").style("visibility", "hidden");

      }


      function mapClicked(event, d) {
        //d is the specific state or county clicked on
        let bounds = path.bounds(d.geometry);


        let dW = bounds[1][0] - bounds[0][0];
        let dH = bounds[1][1] - bounds[0][1];
        let cx = (bounds[0][0] + bounds[1][0]) / 2;
        let cy = (bounds[0][1] + bounds[1][1]) / 2;

        let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dW / w,
          dH / h)));

        let translate = [w / 2 - cx * scale, h / 2 - cy * scale];

        let newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);
        map.transition().duration(1000).call(zoom.transform, newTransform);

      }
      //<div id="filterButton">
      //   <input type="radio" id="stateView" name="filterButton" value="state" checked><label for="stateView">State
      //     View</label>
      //   <input type="radio" id="countyView" name="filterButton" value="county"><label for="countyView">County View</label>
      // </div>
      function toggleView(event) {
        let selectedValue = d3.select(this).property("value");
        countyMode = selectedValue == "county";

        if (countyMode) {
          viewport.select(".county-outline")
            .attr("visibility", "visible");
          viewport.selectAll(".county")
            .attr("visibility", "visible");

          showCountyLegend();
          map.call(zoom.transform, d3.zoomIdentity);
        } else {
          map.call(zoom.transform, d3.zoomIdentity);
        }

      }

    }
    makeChloro();
  </script>
</body>

</html>