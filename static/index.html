<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">

  <style>
    svg {
      /* border: 1px black solid; */
      background-color: rgb(255, 255, 255);
    }

    .county {
      stroke: none;
    }

    .state {
      stroke: none;
    }

    .county-outline {
      stroke: rgb(255, 255, 255);
      stroke-width: 1px;
      fill: none;
    }

    .state-outline {
      stroke: rgb(255, 255, 255);
      fill: none;
    }

    .arealabel {
      user-select: none;
      pointer-events: none;
      font-weight: bold;
      font-size: large;
    }

    table {
      border: 1px solid black;
    }

    .legend-lines {
      stroke: black;
      stroke-width: 2px;
    }

    input[type="radio"].toggle {
      display: none;
    }

    body {
      margin: 50 100 200 200;
      padding: 0;
      font-family: 'Barlow', sans-serif;
    }

    a {
      color: #025FEF;
    }

    p {
      font-weight: 400;
      font-size: 1.2em;
      line-height: 1.5em;
    }

    p.micro {
      font-size: 1.4em;
      font-weight: 700;
      margin: 0 0 0 5;
      padding: 0;
      color: #025FEF;
    }

    p.source {
      margin: -30 0 0 0;
      padding: 0;
    }

    b {
      font-weight: 500;
    }

    ul li {
      font-size: 1.15em;
      line-height: 1.75em;
    }

    h1 {
      font-weight: 800;
      font-size: 7em;
      margin: 0 0 100 0;
      padding: 0;
      line-height: 1em;
      color: #025FEF;
    }

    h1.gradient {
      color: #025FEF;
      background-image: linear-gradient(30deg, #000b88, #0099ff);
      background-clip: text;
      color: transparent;
    }

    h2 {
      font-weight: 500;
      font-size: 4.5em;
      margin: 0 0 40 0;
      padding: 0;
      line-height: 1em;
    }

    .heavy {
      font-weight: 900;
      background-color: #0261ef2d;
    }

    h3 {
      font-size: 2.4em;
      margin: 60 0 30 0;
      padding: 0;
      line-height: 1em;
      color: #025FEF;
    }

    .rate {
      font-size: .5em;
      color: black;
    }

    h4 {
      font-size: 1.3em;
      margin: 30 0 5 0;
      padding: 0;
    }

    .gridlines .domain {
      display: none;
    }

    .gridlines line {
      stroke: #bebebe;
    }

    .gridtext {
      font-size: .8em;
    }

    div.lineContainer {
      float: left;
    }
  </style>
</head>

<body>

  <p class="micro">U.S. STATE AND COUNTY</p>
  <h1>Disability Statistics</h1>
  <h2>Disabled Population<br>in the United States is <span class="heavy">&nbsp;13.4%&nbsp;</span></h2>
  <p class="source">2022 American Community Survey 1-Year Estimates</p>
  <dvi style="clear: both;">
    <div class="lineContainer">
      <h3><span class="rate">DISABILITY PREVALENCE RATES</span><br>By Disability Type</h3>
      <svg id="typePlot" height="350" width="480">
      </svg>
    </div>
    <div class="lineContainer">
      <h3><span class="rate">DISABILITY PREVALENCE RATES</span><br>By Age</h3>
      <svg id="agePlot" height="350" width="480">
      </svg>
    </div>
    <div class="lineContainer">
      <h3><span class="rate">DISABILITY PREVALENCE RATES</span><br>By Race</h3>
      <svg id="racePlot" height="350" width="480">
      </svg>
    </div>
  </dvi>

  <!-- ----------------------------
              CHOROPLETH & TABLE
        ---------------------------- -->
  <div style="clear: both; margin:0; padding: 5 0 0 0;">
    <h3><span class="rate">DISABILITY PREVALENCE RATES</span><br>By State and County</h3>
  </div>

  <div id="filterButton">
    <input type="radio" id="stateView" name="filterButton" value="state" checked><label for="stateView">State
      View</label>
    <input type="radio" id="countyView" name="filterButton" value="county"><label for="countyView">County View</label>
  </div>
  <svg id="legend" height="200" width="400"></svg>

  <svg id="chloroMap" height="600" width="1000"></svg>
  <div id="tableDiv">
    <table id="table">
      <thead>
        <tr id="header">
          <th>Disability Type (ages)</th>
          <th>%</th>
          <th>MOE</th>
          <th>Number</th>
          <th>MOE</th>
          <th>Base Population</th>
        </tr>
      </thead>
      <tbody>
        <tr id="row1">
          <th>Any Disability (under 18)</td>
          <td>10.1</td>
          <td>±0.8</td>
          <td>10,199</td>
          <td>±799</td>
          <td>101,394</td>
        </tr>
        <tr id="row2">
          <th>Hearing (under 18)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row3">
          <th>Hearing (18 - 64)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row4">
          <th>Visual (under 18)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row5">
          <th>Visual (18 - 64)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row6">
          <th>Cognitive (under 18)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row7">
          <th>Cognitive (18 - 64)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row8">
          <th>Ambulatory (under 18)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row9">
          <th>Ambulatory (18 - 64)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row10">
          <th>Selfcare (under 18)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row11">
          <th>Selfcare (18 - 64)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
        <tr id="row12">
          <th>Independent Living (18 - 64)</td>
          <td>2.5</td>
          <td>±0.4</td>
          <td>2,574</td>
          <td>±359</td>
          <td>101,394</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- NOTES -->
  <div style="clear: both;">
    <h4>Notes</h4>
    <p>
      All estimates provided by these visualizations are based on the the most recently available US Census Bureau’s
      American Community Survey (ACS) data 5 year estimates collected from 2017-2022.
      Because the estimates below are based on a sample they have a degree of uncertainty, called sampling error,
      associated with them. In general, the larger the sample, the smaller the level of sampling error. To help users
      understand the impact of sampling error on data reliability, we provide the margin of error (MOE) for each
      estimate. The MOE, combined with the estimate, gives users a range of values within which the actual, real-world
      value is likely to fall.
    </p>
  </div>
  <!-- SOURCES & LINKS -->
  <div class="sourceContainer">
    <h4>Data Source</h4>
    <ul>
      <li>American Community Survey (ACS): S1810 | Disability Characteristics (<a
          href="https://data.census.gov/table?q=Disability">https://data.census.gov/table?q=Disability</a>)</li>
    </ul>
  </div>

  <!---   ==============================
        PREVALENCE: BY DISABILITY TYPE
        ============================== --->
  <script id="notes1">
    // set the dimensions and margins of the graph
    const disLines = d3.select("svg#typePlot");
    const disWidth = disLines.attr("width");
    const disHeight = disLines.attr("height");
    const disMargin = { top: 10, right: 155, bottom: 40, left: 40 };
    const chartWidth = disWidth - disMargin.left - disMargin.right;
    const chartHeight = disHeight - disMargin.top - disMargin.bottom;

    let chartArea = disLines.append("g")
      .attr("transform", `translate(${disMargin.left},${disMargin.top})`);

    // DATA
    d3.csv("prevDisType-01.csv",
      d => {
        return {
          time: d3.timeParse("%Y")(d.time), Disability: d.Disability,
          Hearing: d.Hearing,
          Vision: d.Vision,
          Cognitive: d.Cognitive,
          Ambulatory: d.Ambulatory,
          Selfcare: d.Selfcare,
          IndLiving: d.IndependentLiving
        }
      }
    ).then(function (data) {

      // List of groups (here I have one group per column)
      const allGroup = ["Disability", "Hearing", "Vision", "Cognitive", "Ambulatory", "Selfcare", "IndLiving"]

      // Reformat the data: we need an array of arrays of {x, y} tuples
      const dataReady = allGroup.map(function (grpName) { // .map allows to do something for each element of the list
        return {
          name: grpName,
          values: data.map(function (d) {
            return { time: d.time, value: +d[grpName] };
          })
        };
      });

      // console
      // console.log(dataReady)

      // Color Scale: one color for each group
      const myColor = d3.scaleOrdinal()
        .domain(allGroup)
        .range(d3.schemeCategory10);

      // X-AXIS
      const x = d3.scaleTime()
        .domain(d3.extent(data, d => d.time))
        .range([0, chartWidth]);
      // x-axis: years
      chartArea.append("g")
        .attr("transform", `translate(0, ${chartHeight + 10})`)
        .attr("class", "gridtext")
        .call(d3.axisBottom(x).ticks(5).tickSizeOuter(5).tickSize(7));
      // grey base grid
      chartArea.append("g")
        .attr("transform", `translate(0, ${chartHeight + 10})`)
        .call(d3.axisBottom(x).tickSizeOuter(5).tickSize(-chartHeight).tickFormat(""))
        .attr("class", "gridlines");


      // Y-AXIS
      const y = d3.scaleLinear()
        .domain([1, 14])
        .range([chartHeight, 0]);
      // y-axis numbers
      chartArea.append("g")
        .attr("transform", `translate(-13, 0)`)
        .attr("class", "gridtext")
        .call(d3.axisLeft(y).ticks(5).tickSize(7).tickSizeOuter(5));

      // Add LINES
      const line = d3.line()
        .x(d => x(+d.time))
        .y(d => y(+d.value))
      chartArea.selectAll("myLines")
        .data(dataReady)
        .join("path")
        .attr("class", d => d.name)
        .attr("d", d => line(d.values))
        .attr("stroke", d => myColor(d.name))
        .attr("opacity", .3)
        .style("stroke-width", 3)
        .style("fill", "none")

      // Add POINTS
      chartArea
        // Enter in a group
        .selectAll("myDots")
        .data(dataReady)
        .join('g')
        .style("fill", d => myColor(d.name))
        .attr("class", d => d.name)
        // Second we need to enter in the 'values' part of this group
        .selectAll("myPoints")
        .data(d => d.values)
        .join("circle")
        .attr("cx", d => x(d.time))
        .attr("cy", d => y(d.value))
        .attr("r", 6)
        .attr("stroke", "white")

      // Add a legend (interactive)
      chartArea
        .selectAll("myLegend")
        .data(dataReady)
        .join('g')
        .append("text")
        .attr('x', 310)
        .attr('y', (d, i) => 20 + i * 29)
        .text(d => d.name)
        .style("fill", d => myColor(d.name))
        .style("font-size", 18)
        .on("click", function (event, d) {
          // is the element currently visible ?
          currentOpacity = d3.selectAll("." + d.name).style("opacity")
          // Change the opacity: from 0 to 1 or from 1 to 0
          d3.selectAll("." + d.name).transition().style("opacity", currentOpacity == 1 ? 0 : 1)
        })
    })
  </script>
  <!---   ==============================
              PREVALENCE: BY AGE
        ============================== --->
  <script id="notes2">
    // set the dimensions and margins of the graph
    const ageLines = d3.select("svg#agePlot");
    const ageWidth = ageLines.attr("width");
    const ageHeight = ageLines.attr("height");
    const ageMargin = { top: 10, right: 155, bottom: 40, left: 40 };
    const ageChartWidth = ageWidth - ageMargin.left - ageMargin.right;
    const ageChartHeight = ageHeight - ageMargin.top - ageMargin.bottom;

    let ageChartArea = ageLines.append("g")
      .attr("transform", `translate(${ageMargin.left},${ageMargin.top})`);

    // DATA
    d3.csv("prevAge-01.csv",
      d => {
        return {
          time: d3.timeParse("%Y")(d.time), Under5: d.under5,
          Age5to17: d.age5to17,
          Age18to34: d.age18to34,
          Age35to64: d.age35to64,
          Age65to74: d.age65to74,
          Over75: d.over75
        }
      }
    ).then(function (data) {

      // List of groups (here I have one group per column)
      const allGroup = ["Under5", "Age5to17", "Age18to34", "Age35to64", "Age65to74", "Over75"]

      // Reformat the data: we need an array of arrays of {x, y} tuples
      const dataReady = allGroup.map(function (grpName) { // .map allows to do something for each element of the list
        return {
          name: grpName,
          values: data.map(function (d) {
            return { time: d.time, value: +d[grpName] };
          })
        }; u
      });

      // console
      // console.log(dataReady)

      // Color Scale: one color for each group
      const myColor = d3.scaleOrdinal()
        .domain(allGroup)
        .range(d3.schemeCategory10);

      // X-AXIS
      const x = d3.scaleTime()
        .domain(d3.extent(data, d => d.time))
        .range([0, ageChartWidth]);
      // x-axis: years
      ageChartArea.append("g")
        .attr("transform", `translate(0, ${ageChartHeight + 10})`)
        .attr("class", "gridtext")
        .call(d3.axisBottom(x).ticks(5).tickSizeOuter(0).tickSize(7));
      // grey base grid
      ageChartArea.append("g")
        .attr("transform", `translate(0, ${ageChartHeight + 10})`)
        .call(d3.axisBottom(x).tickSizeOuter(0).tickSize(-ageChartHeight).tickFormat(""))
        .attr("class", "gridlines");


      // Y-AXIS
      const y = d3.scaleLinear()
        .domain([0, 50])
        .range([ageChartHeight, 0]);
      // y-axis numbers
      ageChartArea.append("g")
        .attr("transform", `translate(-13, 0)`)
        .attr("class", "gridtext")
        .call(d3.axisLeft(y).ticks(5).tickSize(7).tickSizeOuter(0));

      // Add LINES
      const line = d3.line()
        .x(d => x(+d.time))
        .y(d => y(+d.value))
      ageChartArea.selectAll("myLines")
        .data(dataReady)
        .join("path")
        .attr("class", d => d.name)
        .attr("d", d => line(d.values))
        .attr("stroke", d => myColor(d.name))
        .attr("opacity", .3)
        .style("stroke-width", 3)
        .style("fill", "none")

      // Add POINTS
      ageChartArea
        // Enter in a group
        .selectAll("myDots")
        .data(dataReady)
        .join('g')
        .style("fill", d => myColor(d.name))
        .attr("class", d => d.name)
        // Second we need to enter in the 'values' part of this group
        .selectAll("myPoints")
        .data(d => d.values)
        .join("circle")
        .attr("cx", d => x(d.time))
        .attr("cy", d => y(d.value))
        .attr("r", 6)
        .attr("stroke", "white")

      // Add a legend (interactive)
      ageChartArea
        .selectAll("myLegend")
        .data(dataReady)
        .join('g')
        .append("text")
        .attr('x', 310)
        .attr('y', (d, i) => 20 + i * 30)
        .text(d => d.name)
        .style("fill", d => myColor(d.name))
        .style("font-size", 18)
        .on("click", function (event, d) {
          // is the element currently visible ?
          currentOpacity = d3.selectAll("." + d.name).style("opacity")
          // Change the opacity: from 0 to 1 or from 1 to 0
          d3.selectAll("." + d.name).transition().style("opacity", currentOpacity == 1 ? 0 : 1)
        })
    })

  </script>

  <!---   ==============================
              PREVALENCE: BY RACE
        ============================== --->
  <script id="notes3">
    // set the dimensions and margins of the graph
    const raceLines = d3.select("svg#racePlot");
    const raceWidth = raceLines.attr("width");
    const raceHeight = raceLines.attr("height");
    const raceMargin = { top: 10, right: 155, bottom: 40, left: 40 };
    const raceChartWidth = raceWidth - raceMargin.left - raceMargin.right;
    const raceChartHeight = raceHeight - raceMargin.top - raceMargin.bottom;

    let raceChartArea = raceLines.append("g")
      .attr("transform", `translate(${raceMargin.left},${raceMargin.top})`);

    // DATA
    d3.csv("prevRace-01.csv",
      d => {
        return {
          time: d3.timeParse("%Y")(d.time), White: d.White,
          BlackAA: d.BlackAA,
          AmerIndAKNat: d.AmerIndAKNat,
          Asian: d.Asian,
          HawaiianPI: d.HawaiianPI,
          OtherRace: d.OtherRace,
          TwoPlusRaces: d.TwoPlusRaces,
          WhiteNotHisp: d.WhiteNotHisp,
          HispAnyRace: d.HispAnyRace
        }
      }
    ).then(function (data) {

      // List of groups (here I have one group per column)
      const allGroup = ["White", "BlackAA", "AmerIndAKNat", "Asian", "HawaiianPI", "OtherRace", "TwoPlusRaces", "WhiteNotHisp", "HispAnyRace"]

      // Reformat the data: we need an array of arrays of {x, y} tuples
      const dataReady = allGroup.map(function (grpName) { // .map allows to do something for each element of the list
        return {
          name: grpName,
          values: data.map(function (d) {
            return { time: d.time, value: +d[grpName] };
          })
        };
      });

      // console
      // console.log(dataReady)

      // Color Scale: one color for each group
      const myColor = d3.scaleOrdinal()
        .domain(allGroup)
        .range(d3.schemeCategory10);

      // X-AXIS
      const x = d3.scaleTime()
        .domain(d3.extent(data, d => d.time))
        .range([0, raceChartWidth]);
      // x-axis: years
      raceChartArea.append("g")
        .attr("transform", `translate(0, ${raceChartHeight + 10})`)
        .attr("class", "gridtext")
        .call(d3.axisBottom(x).ticks(5).tickSizeOuter(5).tickSize(7));
      // grey base grid
      raceChartArea.append("g")
        .attr("transform", `translate(0, ${raceChartHeight + 10})`)
        .call(d3.axisBottom(x).tickSizeOuter(5).tickSize(-raceChartHeight).tickFormat(""))
        .attr("class", "gridlines");


      // Y-AXIS
      const y = d3.scaleLinear()
        .domain([6, 18])
        .range([raceChartHeight, 0]);
      // y-axis numbers
      raceChartArea.append("g")
        .attr("transform", `translate(-13, 0)`)
        .attr("class", "gridtext")
        .call(d3.axisLeft(y).ticks(5).tickSize(7).tickSizeOuter(5));

      // Add LINES
      const line = d3.line()
        .x(d => x(+d.time))
        .y(d => y(+d.value))
      raceChartArea.selectAll("myLines")
        .data(dataReady)
        .join("path")
        .attr("class", d => d.name)
        .attr("d", d => line(d.values))
        .attr("stroke", d => myColor(d.name))
        .attr("opacity", .3)
        .style("stroke-width", 3)
        .style("fill", "none")

      // Add POINTS
      raceChartArea
        // Enter in a group
        .selectAll("myDots")
        .data(dataReady)
        .join('g')
        .style("fill", d => myColor(d.name))
        .attr("class", d => d.name)
        // Second we need to enter in the 'values' part of this group
        .selectAll("myPoints")
        .data(d => d.values)
        .join("circle")
        .attr("cx", d => x(d.time))
        .attr("cy", d => y(d.value))
        .attr("r", 6)
        .attr("stroke", "white")

      // Add a legend (interactive)
      raceChartArea
        .selectAll("myLegend")
        .data(dataReady)
        .join('g')
        .append("text")
        .attr('x', 310)
        .attr('y', (d, i) => 20 + i * 30)
        .text(d => d.name)
        .style("fill", d => myColor(d.name))
        .style("font-size", 18)
        .on("click", function (event, d) {
          // is the element currently visible ?
          currentOpacity = d3.selectAll("." + d.name).style("opacity")
          // Change the opacity: from 0 to 1 or from 1 to 0
          d3.selectAll("." + d.name).transition().style("opacity", currentOpacity == 1 ? 0 : 1)
        })
    })

  </script>


  <script>
    /*  
    =================== hover effect ===========================================
    */
    const labelRectangleHeight = 40;
    const pixelsPerLetter = 11; //used to calculate width of rectangle
    const areaNameFontSize = 14;
    const percentageFontSize = 12;
    const labelVerticalAdjustment = 25;
    /*
    =================== color legends ==========================================
    */
    const stateLegendX = 25; //position from top left corner of the second svg. 
    const stateLegendY = 100;

    const countyLegendX = 25;
    const countyLegendY = 100;

    const boxHeight = 20;
    const boxWidth = 40;
    // const boxSeperation = 25; //vertical distances between boxes
    const boxTextSeperation = 25; //horizontal distance between start of the leftmost letter and the left of the box 
    const textVerticalAdjustment = 15; //probably don't change this one unless you change font or font size
    const extraLineHeight = 10;

    /*
    ========================= table ============================================
    */



    const row1 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population",
      "Estimate!!Total!!Total civilian noninstitutionalized population"];
    // Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty

    const row2 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years",
      "Estimate!!Total!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population under 18 years"];

    const row3 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a hearing difficulty!!Population 18 to 64 years",
      "Estimate!!Total!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years"];

    const row4 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population under 18 years"
    ];


    const row5 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a vision difficulty!!Population 18 to 64 years"
    ];

    const row6 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population under 18 years"
    ];

    const row7 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a cognitive difficulty!!Population 18 to 64 years"
    ];

    const row8 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population under 18 years"
    ];


    const row9 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an ambulatory difficulty!!Population 18 to 64 years"
    ];

    const row10 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population under 18 years"
    ];

    const row11 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With a self-care difficulty!!Population 18 to 64 years"
    ];

    const row12 = [
      "Estimate!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years",
      "Margin of Error!!Percent with a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years",
      "Estimate!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years",
      "Margin of Error!!With a disability!!Total civilian noninstitutionalized population!!DISABILITY TYPE BY DETAILED AGE!!With an independent living difficulty!!Population 18 to 64 years"
    ];

    const tableKeys = [row1, row2, row3, row4, row5, row6, row7, row8, row9, row10, row11, row12];



    function updateTable(dataObject) {
      let tbody = d3.select("table#table tbody");
      let rows = tbody.selectAll("tr");
      rows.each(function (_, rowIndex) {
        let cells = d3.select(this).selectAll("td");
        cells.each(function (_, cellIndex) {
          let cell = d3.select(this);
          let propertyName = tableKeys[rowIndex][cellIndex];


          if (propertyName == undefined) {
            if (rowIndex % 2 == 0) {
              propertyName = tableKeys[1][cellIndex];
            } else {
              propertyName = tableKeys[2][cellIndex];

            }
          }
          cell.text(dataObject[propertyName]);
        });
      });

    }



    d3.select("table#table").style("visibility", "hidden");
    let countyMode = false;

    async function makeChloro() {
      d3.selectAll("input[name='filterButton']").on("change", toggleView);

      let topo = await d3.json("us.json"); let
        filteredStates = ['72', '78']; topo.objects.states.geometries = topo.objects.states.geometries.filter(d => {
          return filteredStates.indexOf(d.id.toString().padStart(2, '0')) === -1;
        });

      let disabilityData = await d3.csv("ACSST5Y2022.S1810-Data.csv");

      disabilityData.forEach(d => {
        d["Geography"] = Number(d["Geography"].substr(9));
        d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"] = Number(d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]);
      });


      // console.log(disabilityData);

      fipsToStats = {};

      disabilityData.forEach(d => {
        fipsToStats[d["Geography"]] = d;
      });


      // for a combined scale if wanted
      let allPercentages = d3.map(disabilityData, d => {
        return Number(d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]);
      });
      let statePercentages = disabilityData.map(d => {
        if (!d["Geographic Area Name"].includes(",")) return d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"];
      });

      let countyPercentages = disabilityData.map(d => {
        if (d["Geographic Area Name"].includes(",")) return d["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"];
      });


      let colors = ["#CFE1F2", "#B5D4E9", "#93C3DF", "#6DAED5", "#4B97C9", "#2F7EBC", "#1864AA", "#0A4A90", "#08306B"];

      let percentageExtent = d3.extent(allPercentages);
      let adjustedPurple = d3.schemeBlues[9].slice(2);

      let colorScaleState = d3.scaleQuantize(d3.extent(statePercentages), colors);
      let colorScaleCounty = d3.scaleQuantize(d3.extent(countyPercentages), colors);
      // 
      // 
      // Legend Stuff
      // 
      // 
      let svg = d3.select("svg#legend");

      const numberOfSteps = colorScaleState.range().length;
      const legendData = colorScaleState.range().map((color, i) => {
        const extent = colorScaleState.invertExtent(color);
        return {
          color: color,
          minValue: extent[0],
          maxValue: extent[1]
        };
      });


      svg.append("text")
        .text("Prevalence Rate of Disability (%)")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("user-select", "none")
        .attr("transform", `translate(${numberOfSteps * boxWidth / 2}, ${75})`);
      let legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${stateLegendX}, ${stateLegendY})`); // Adjust x, y to position your legend



      // Draw legend boxes
      legend.selectAll(".legend-box")
        .data(legendData)
        .enter()
        .append("rect")
        .attr("class", "legend-box")
        .attr("x", (d, i) => i * boxWidth)
        .attr("y", 0)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .style("fill", d => d.color);

      // Add legend labels
      legend.selectAll(".legend-label")
        .data(legendData)
        .enter()
        .append("text")
        .attr("class", "legend-label")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "hanging")
        .style("user-select", "none")
        .attr("x", (d, i) => i * boxWidth) // Adjust position relative to boxes
        .attr("y", boxHeight + extraLineHeight) // Align text with boxes
        .text((d, i) => {
          if (i == numberOfSteps - 1) return `${d.minValue.toFixed(1)}`;
          return `${d.minValue.toFixed(1)}`;
        });

      legend.selectAll(".legend-lines")
        .data(legendData)
        .enter()
        .append("line")
        .attr("class", "legend-lines")
        .attr("x1", (d, i) => i * boxWidth)
        .attr("x2", (d, i) => i * boxWidth)
        .attr("y1", 0)
        .attr("y2", boxHeight + extraLineHeight);

      let legend2 = svg.append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${countyLegendX}, ${countyLegendY})`)
        .style("display", "none");
      numberOfStepsCounty = colorScaleCounty.range().length;
      const legendDataCounty = colorScaleCounty.range().map((color, i) => {
        const extent = colorScaleCounty.invertExtent(color);
        return {
          color: color,
          minValue: extent[0],
          maxValue: extent[1]
        };
      });


      // Draw legend boxes
      legend2.selectAll(".legend-box")
        .data(legendDataCounty)
        .enter()
        .append("rect")
        .attr("class", "legend-box")
        .attr("x", (d, i) => i * boxWidth)
        .attr("y", 0)
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .style("fill", d => d.color);

      // Add legend labels
      legend2.selectAll(".legend-label")
        .data(legendDataCounty)
        .enter()
        .append("text")
        .attr("class", "legend-label")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "hanging")
        .style("user-select", "none")
        .attr("x", (d, i) => i * boxWidth) // Adjust position relative to boxes
        .attr("y", boxHeight + extraLineHeight) // Align text with boxes
        .text((d, i) => {
          if (i == numberOfSteps - 1) return `${d.minValue.toFixed(1)}`;
          return `${d.minValue.toFixed(1)}`;
        });

      legend2.selectAll(".legend-lines")
        .data(legendDataCounty)
        .enter()
        .append("line")
        .attr("class", "legend-lines")
        .attr("x1", (d, i) => i * boxWidth)
        .attr("x2", (d, i) => i * boxWidth)
        .attr("y1", 0)
        .attr("y2", boxHeight + extraLineHeight);

      //

      function showCountyLegend() {
        legend.style("display", "none");
        legend2.style("display", null);
      }

      function showStateLegend() {
        legend.style("display", null);
        legend2.style("display", "none");
      }


      let states = topojson.feature(topo, topo.objects.states);
      let statesMesh = topojson.mesh(topo, topo.objects.states);
      let counties = topojson.feature(topo, topo.objects.counties);
      let countiesMesh = topojson.mesh(topo, topo.objects.counties);

      let map = d3.select("svg#chloroMap");
      let w = map.attr("width");
      let h = map.attr("height");
      let projection = d3.geoAlbersUsa().fitSize([w, h], states);
      let path = d3.geoPath().projection(projection);

      let viewport = map.append("g");

      viewport.selectAll(".state").data(states.features)
        .enter()
        .append("path")
        .attr("class", "state")
        .attr("id", d => d.id)
        .attr("d", path);

      viewport.append("path")
        .datum(statesMesh)
        .attr("class", "state-outline")
        .attr("d", path);


      viewport.selectAll(".county").data(counties.features)
        .enter()
        .append("path")
        .attr("class", "county")
        .attr("d", path);

      viewport.append("path")
        .datum(countiesMesh)
        .attr("class", "county-outline")
        .attr("d", path);

      let areaLabel = viewport.append("g");
      let areaLabelRect = areaLabel.append("rect")
        .attr("stroke", "black");

      const trianglePoints = [[-10, 0], [10, 0], [0, 20]]
      let areaLabelTriangle = areaLabel.append("polygon")
        .attr("points", trianglePoints.map(point => point.join(",")).join(" "))
        .style("fill", "orangered")
        .style("stroke", "black")
        .style("stroke-width", 1);
      let areaLabelName = areaLabel.append("text")
        .attr("class", "arealabel")
        .style("font-size", `${areaNameFontSize} px`);
      let areaLabelStat = areaLabel.append("text")
        .attr("class", "areastat")
        .style("font-size", `${percentageFontSize} px`);




      //zooming
      var zoom = d3.zoom()
        .scaleExtent([1, 20])
        .translateExtent([[-50, -50], [w + 50, h + 50]])
        .on("zoom", mapZoom);

      map.call(zoom);
      //to hide counties
      map.call(zoom.transform, d3.zoomIdentity);

      function mapZoom({ transform }) {
        viewport.attr("transform", transform.toString());
        viewport.select(".state-outline")
          .style("stroke-width", 2 / transform.k);
        viewport.select(".county-outline")
          .style("stroke-width", 1 / transform.k);

        if (!countyMode) {
          viewport.select(".county-outline")
            .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
          viewport.selectAll(".county")
            .attr("visibility", (transform.k > 3) ? "visible" : "hidden");
        }


        console.log(transform.k);

        if (transform.k > 3) {
          showCountyLegend();
          stateUnhover();
        } else if (!countyMode) {
          showStateLegend();
          // countyUnhover(); 
        }

        // hover label box
        // let newScale = Math.min(Math.max(1 / transform.k, 0.5), 1);
        // let curWidth = areaLabelRect.attr("width");
        // let newWidth = curWidth * newScale;
        // let newHeight = labelRectangleHeight * newScale;
        // let newNameFontSize = areaNameFontSize * newScale;


        // areaLabelRect
        //   .attr("width", newWidth)
        //   .attr("height", newHeight);
        // areaLabel.selectAll("text")
        //   .style("font-size", `${newNameFontSize} px`);
      }


      viewport.selectAll(".state").on("click", mapClicked);
      viewport.selectAll(".county").on("click", mapClicked);

      viewport.selectAll(".state")
        .attr("fill", d => {
          let val = fipsToStats[d.id];
          if (!val) {
            console.error('No data for id:', d.id);
            return '#000'; // Or any fallback color
          }
          return colorScaleState(Number(fipsToStats[d.id]["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]))
        });

      viewport.selectAll(".county").attr("fill", d => {
        const stats = fipsToStats[d.id];
        if (!stats) {
          // console.log("Missing data for ID:", d.id); // Log missing IDs
          return "#000"; // Default color for missing data
        }
        return colorScaleCounty(Number(stats["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"]));
      });
      viewport.selectAll(".state").on("mouseover", stateHover).on("mouseleave", stateUnhover);
      viewport.selectAll(".county").on("mouseover", countyHover).on("mouseleave", countyUnhover);



      // viewport.selectAll(".county").on("mouseover", countyHover);




      function stateHover(event, d) {
        d3.selectAll(".state")
          .transition()
          .duration(200)
          .style("opacity", .4);
        d3.select(this).raise()
          .transition()
          .duration(200)
          .style("opacity", 1)
          .style("stroke", "black")
          .style("stroke-width", "3px");

        // label stuff
        let bounds = path.bounds(d.geometry);


        let dW = bounds[1][0] - bounds[0][0];
        let dH = bounds[1][1] - bounds[0][1];
        let cx = (bounds[0][0] + bounds[1][0]) / 2;
        let ty = (bounds[0][1]) - labelVerticalAdjustment;
        let cy = (bounds[0][1] + bounds[1][1]) / 2;
        areaLabel.attr("visibility", "visible");


        let areaName = fipsToStats[d.id]["Geographic Area Name"];
        areaLabelName
          .text(areaName)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", labelRectangleHeight / 3);

        areaLabelStat
          .text(fipsToStats[d.id]["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"] + "%")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", 5 + 2 * labelRectangleHeight / 3);

        areaLabelRect
          .attr("width", areaName.length * pixelsPerLetter)
          .attr("height", labelRectangleHeight)
          .attr("rx", 0)
          .attr("fill", "orangered")

        areaLabelTriangle
          .attr("transform", `translate(${areaLabelRect.attr("width") / 2}, ${labelRectangleHeight})`)

        areaLabel.attr("transform", `translate(${cx - areaLabelRect.attr("width") / 2}, ${ty})`).raise();

        // table stuff
        d3.select("table#table").style("visibility", "visible");
        updateTable(fipsToStats[d.id]);

      }

      function stateUnhover(event, d) {
        d3.selectAll(".state").lower()
          .transition()
          .duration(200)
          .style("opacity", 1)
          .style("stroke", "none");
        // d3.select(this).lower()
        //   .transition()
        //   .duration(200)
        //   .style("opacity", 1)
        //   .style("stroke", "none");

        areaLabelName.text("");
        areaLabel.attr("visibility", "hidden");

        d3.select("table#table").style("visibility", "hidden");
      }

      function countyHover(event, d) {
        d3.select(this).raise()
          .transition()
          .duration(200)
          .style("opacity", 1)
          .style("stroke", "black")
          .style("stroke-width", "3px");

        let bounds = path.bounds(d.geometry);


        let dW = bounds[1][0] - bounds[0][0];
        let dH = bounds[1][1] - bounds[0][1];
        let cx = (bounds[0][0] + bounds[1][0]) / 2;
        let cy = (bounds[0][1] + bounds[1][1]) / 2;
        areaLabel.attr("visibility", "visible");

        let areaName = fipsToStats[d.id]["Geographic Area Name"];
        areaLabelName
          .text(areaName)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", labelRectangleHeight / 3);

        areaLabelStat
          .text(fipsToStats[d.id]["Estimate!!Percent with a disability!!Total civilian noninstitutionalized population"] + "%")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("x", (areaName.length * pixelsPerLetter) / 2)
          .attr("y", 5 + 2 * labelRectangleHeight / 3);

        areaLabelRect
          .attr("width", areaName.length * pixelsPerLetter)
          .attr("height", labelRectangleHeight)
          .attr("rx", 0)
          .attr("fill", "orangered")
        areaLabel.attr("transform", `translate(${cx - 50}, ${cy - 50})`).raise();

        //
        d3.select("table#table").style("visibility", "visible");
        updateTable(fipsToStats[d.id]);

      }

      function countyUnhover(event, d) {
        d3.selectAll(".county")
          .transition()
          .duration(200)
          .style("opacity", 1)
          .style("stroke", "none");

        // d3.select(this)
        //   .transition()
        //   .duration(200)
        //   .style("opacity", 1)
        //   .style("stroke", "none");

        areaLabelName.text("");
        areaLabel.attr("visibility", "hidden");


        d3.select("table#table").style("visibility", "hidden");

      }


      function mapClicked(event, d) {
        console.log(d);
        //d is the specific state or county clicked on
        let bounds = path.bounds(d.geometry);


        let dW = bounds[1][0] - bounds[0][0];
        let dH = bounds[1][1] - bounds[0][1];
        let cx = (bounds[0][0] + bounds[1][0]) / 2;
        let cy = (bounds[0][1] + bounds[1][1]) / 2;

        let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dW / w,
          dH / h)));

        let translate = [w / 2 - cx * scale, h / 2 - cy * scale];

        let newTransform = d3.zoomIdentity
          .translate(translate[0], translate[1])
          .scale(scale);
        map.transition().duration(1000).call(zoom.transform, newTransform);

      }
      //<div id="filterButton">
      //   <input type="radio" id="stateView" name="filterButton" value="state" checked><label for="stateView">State
      //     View</label>
      //   <input type="radio" id="countyView" name="filterButton" value="county"><label for="countyView">County View</label>
      // </div>
      function toggleView(event) {
        let selectedValue = d3.select(this).property("value");
        countyMode = selectedValue == "county";

        if (countyMode) {
          viewport.select(".county-outline")
            .attr("visibility", "visible");
          viewport.selectAll(".county")
            .attr("visibility", "visible");

          showCountyLegend();
        } else {
          map.call(zoom.transform, d3.zoomIdentity);
        }

      }

    }
    makeChloro();
  </script>
</body>

</html>